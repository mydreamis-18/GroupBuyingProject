-- [ 22.10.11 ]

-- 16:43
프로젝트 주제는 공동 구매의 쇼핑몰 페이지

-- git 계정도 새로 생성했음!

-- 지금은 익숙하지만 언젠간 까먹을 지 모를 필요한 git 명령어
git init
git config --global user.name "mydreamis-18"
git config --global user.email "email"
git config --global --list
git branch -M main
git remote add origin https://github.com/mydreamis-18/GroupBuyingProject.git
git add .
git commit -m "first commit"
git push -u origin main

-- 자 여기서 1st 문제 발생...
remote: Permission to mydreamis-18/GroupBuyingProject.git denied to mydreamis-a.
fatal: unable to access 'https://github.com/mydreamis-18/GroupBuyingProject.git/': The requested URL returned error: 403

-- 해결 방법
제어판 - 사용자 계정 - windows 자격 증명 관리 - github 계정 제거 후 git push 재시도

-- 17:05
오늘 목표
상품 등록 페이지 완성
전체적인 환경 구축 및 상품 데이터에 대한 시퀄라이즈 완성

-- front 리액트 폴더 생성 명령어
npx create-react-app front

-- back 명령어
npm init -y
npm --save-dev nodemon
npm i express sequelize mysql2 redux react-redux redux-thunk react-router-dom axios cors styled-components

-- .gitignore 파일
node_modules/

-- 17:17
그 다음 할 일
백엔드 서버 연결
프론트와 백엔드 연결

-- 17:34
백엔드 서버 연결 작업 순서
1. app.js 파일 생성 => express().listen(PORT)
2. .env 파일 생성 => DATABASE_PASSWORD = ""
3. config 파일 생성 => MySQL 연결을 위한 config 객체 생성
4. model 폴더 생성 => db 객체 생성 => sequelize 키 값에 MySQL 연결 객체 생성
5. app.js 파일 => MySQL 연동 => sequelize.sync({ force: false })

-- 18:05
프론트와 백엔드 연결 중 2nd 문제 발생
Warning: Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.

-- 해결
문법 => { AddProduct } => <AddProduct />

-- 18:16
스타일드 컴포넌트 설정 중 3rd 문제 발생
Uncaught Error: Cannot find module 'styled-components'

-- 해결
여러 가지의 npm 모듈을 동시에 설치할 때 글자 수 제한이 있나 봄... 재설치 진행

-- 18:20
스타일드 컴포넌트 설정 중 4th 문제 발생
Warning: The tag <flex_temp> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.

-- 해결
문법 => flex_temp => Flex_temp

5th 문제 발생
Imported JSX component Flex_temp must be in PascalCase or SCREAMING_SNAKE_CASE

-- 해결
문법 => Flex_temp => FlexTemp

-- 18:29
상품 등록 페이지
프론트 1차 뼈대 완료

이제 axios 사용해서 백엔드로 인풋 데이터 넘기기
백엔드 시퀄라이즈 모델 생성하기

리덕스는 나중에 하자...

-- 18:39
프론트 파일명 변경 후 parsing error 6th 문제 발생

-- 해결
리액트 서버 종료 후 재실행

-- 18:43
프론트 input 값에 useRef() 함수 사용하기

여러 개의 useRef() 관리하기
=> 초기 값을 배열로 선언
=> <input ref={(el) => (product.current[0] = el)} />

-- 18:58
axios 사용하기
axios 사용하려면 데이터의 동기적 처리를 위해 미들웨어 환경을 먼저 구축해놔야 하는 군...

-- 19:18
프론트 저장소 생성 및 props 전달 중 7th 문제 발생
Uncaught Error: Cannot find module 'react-redux'

-- 해결
아무래도 모듈이 누락 설치된 듯... 재설치 진행

-- 프론트 redux 저장소 작업 순서
1. store 파일 생성 => 저장소 생성 => createStore(reducer, applyMiddleware(thunk))
2. reducer 파일 생성 => reducer() 함수 선언
3. middleware 폴더의 action 파일 생성 => axios 사용하는 함수 선언
4. index.js 파일 => Provider 컴포넌트에 props로 저장소 전달 => <Provider store={store}>

-- 19:31
이제 axios를 사용해보자!

프론트 쪽 연결 중...

-- 19:55
백엔드에 data가 도달하는 지 확인해보려는데 8th 문제 발생
Uncaught (in promise) TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'HTMLInputElement'

운동 가야 하므로 일단 여기까지...
집에 가서 꼭 해결하자꾸나!

-- [ 22.10.12 ]

-- 01:52
노트북 깃 설정에서 9th 문제 발생
fatal: not a git repository (or any of the parent directories): .git

-- 해결
git init을 안 해서...

-- 07:55
지하철 안 작업 중 10th 문제 발생
ConnectionError [SequelizeConnectionError]: Unknown database 'gb_project'

-- 해결
MySQL 스키마 생성을 안 해서...

-- 08:15
컨디션이 안 좋군...

-- 8th 문제 해결
HTML 태그가 담겨있어서 그런 것인가, 아니면 그로 인한 순환 참조 같은 문제가 발생한 것인가...

useRef() 함수 객체의 그 자체를 백엔드로 보내면 에러가 발생하여
input의 onChange() 함수를 통해 useRef() 함수 객체의 value 키 값을 배열로 만든 다음 원하는 값을 담아 객체로 전달

그런데 여기서 ref란...
onChange() 함수 없이도 실시간으로 값이 바뀌는 것인가...

-- 구글링
useRef() 를 사용하여 Ref 객체를 만들고, 이 객체를 우리가 선택하고 싶은 DOM 에 ref 값으로 설정해주어야 합니다.
그러면, Ref 객체의 .current 값은 우리가 원하는 DOM 을 가르키게 됩니다.

-- 08:48
input type="number" step="1000" min="0"

-- 09:38
작업 일지 작성 완료
작업 시작

-- 09:52
숫자 input 예외 처리 중 11th 문제 발생
Warning: Invalid value for prop `value` on <input> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM.

-- 다른 방식으로 해결
type="number" 설정을 하고
onChange() 함수를 사용하니
아무리 if (e.target.value) 조건을 걸어도
문자 입력 시에 onChange() 함수가 실행되지 않아
입력한 문자가 계속 해서 남아 있는 상태

onChange() 함수 대신
onInput() 함수로 바꾸니
onIntput() 함수가 정상적으로 실행되어
if 조건으로 문자 입력 시
e.target.value 값을 초기화시킴

두 함수에 미세한 차이가 있는 듯 한데
그건 다음에 알아보도록 하자.

-- 10:31
금액 input 태그에 천 단위 쉼표를 넣고 싶었으나
tpye="number" 설정 때문인지 쉼표가 삽입되지 않음
아무래도 둘 중 하나를 선택해야 될 듯...

그래도 나중을 위해 방법 기록해두기!
e.target.value = Number(e.target.value).toLocaleString();

-- 10:49
ref 객체에 배열 대신 객체로 담기

-- 11:15
input 태그의 isNull 유효성 체크 완료
이제 날짜의 유효성 검사를....

npm install react-datepicker --save

datepicker 참고 링크
https://reactdatepicker.com/#example-select-time

-- 11:35
index.js 파일에서 datepicker style 조정

.react-datepicker-wrapper {
  width: auto !important;
}

-- 13:05
판매 시작 시각과 종료 시각의 유효성 체크
날짜는 완료

시간은 패스...

datepicker에서
showTimeSelect 설정을 사용하려면 minTime, maxTime 설정 필요

showTimeInput 설정은 minTime, maxTime 설정해도 안 되는 듯...

minTime 및 maxTime 설정을 위해
setMinutes, setHours 함수를 사용하려면 import 필요

import setHours from "date-fns/setHours";
import setMinutes from "date-fns/setMinutes";

-- 14:13
현재 이후의 시간을 선택하도록 날짜 및 시간에 대한 유효성을 체크하는 함수 구현 완료

이제 데이터가 잘 넘어가는 지 한 번 보자.
이름, 이미지, 설명만 넘어가는 군...

숫자 input은 되었다 안 되었다 하는 건지 예의주시 필요

선택한 날짜 데이터를 사용하기 위해
자식 컴포넌트가 아닌 부모 컴포넌트에서 state 값 사용

-- 14:59
12th 문제 발생
그런데 백엔드의 날짜 데이터가 axiois before 값과 다른 값이군... '2022-10-12T05:35:18.107Z'

-- 15:24
product 모델 생성 중 13th 문제 발생
Product.init is not a function

-- 해결
모델 class의 js 파일 => 문법 => module.exports = 모델명
모델 폴더의 index.js 파일 => 문법 => module.exports = { sequelize, 모델명 }

-- 15:38
시퀄라이즈 테이블에 데이터를 추가할 때
객체의 키 값과 컬럼명이 전부 동일할 경우
객체명만 전달하여 데이터를 추가할 수 있음!

그런데 상품 등록 버튼을 1번 클릭했음에도 불구하고
같은 데이터가 여러 번 추가되는 문제 발생
거기다 랜덤임...
예의주시 필요...

-- 16:13
12th 문제 고민
프론트의 날짜 데이터의 타입은 object
백엔드로 넘어온 날짜 데이터의 타입은 string

데이터를 어떻게 사용할 것이냐에 따라
데이터를 어떻게 저장할 지 정해야 하는데...

상품 상세 페이지에서 남은 시간을 표시하는 데 사용해야 해...

-- 17:06
타임스탬프 date.getTime()으로 저장하겠어...

-- 17:39
상품 이미지 미리 보기 구현 중 14th 문제 발생
Uncaught TypeError: Failed to execute 'createObjectURL' on 'URL': Overload resolution failed.

-- 다른 방식으로 해결
URL.createObjectURL(product.value.img) => 삼항 연산자 => URL.createObjectURL(img)
아마도 사진 선택 전에는 value 객체에 img 키 값이 없어서 그런 듯...

그리고 삼항 연산자를 사용하더라도 ref 객체의 값이 바뀌는 거라 리렌더링되지 않아서 선택한 사진이 적용되지 않는 듯...
별개의 useState 값을 사용하여 리렌더링을 유도함으로써 해결

-- 18:53
이제 문제는 MySQL에 이미지 파일 저장하는 것...

multer 모듈을 사용하려면 form 태그를 반드시 사용해야만 하는 건가 => 놉
form 태그를 사용할 수도 있고 formData() 객체를 사용해서 axios 통신을 할 수도 있음

그런데 form으로 사후처리가 가능하던가?

-- 19:57
흑 정말이지 욕 하기 싫은데 욕 하고 싶다...
formData...

-- 20:30
모든 input 태그에 값이 있으나 ref 객체에 데이터가 저장되지 않는 15th 문제 발생
POST http://localhost:8000/addProduct net::ERR_CONNECTION_REFUSED
Uncaught (in promise) AxiosError {message: 'Network Error',
WHERE parameter "name" has invalid "undefined" value

ref 객체의 문제인가...
리렌더링에도 유지되는 범위는 current 키 값 한정인가...

-- 21:22
겁나 허탈하게...
숫자 타입 input 태그의 onChange() 함수를 지우니
저절로 문자 입력이 되지 않는다...

-- 21:37
ref 객체는 모두 current 키 값만 사용하도록 변경 완료

ref 객체 그대로를 백엔드로 보낼 경우 발생했던 8th 문제에 대하여
current 키 값에 태그 대신 value 값으로 덮어씌움으로써 해결함!

이제 다음 작업은...
등록된 상품 정보를 이용해 상품 상세 페이지 구현

-- [ 22.10.13 ]

-- 10:04
작업 일지 작성 완료
작업 시작

오늘 먼저 할 것

상품 상세 페이지 뼈대 구현

라우터 설정을 먼저 해야겠군요~

-- 라우터 설정 중에 15th 문제 발생
Uncaught Error: [Router] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>

-- 해결
문법 => Route

라우터 설정 완료

우선 DB의 데이터를 가져와 봐야겠군...

-- question
1) 액션이 담긴 미들웨어 함수에서 액션은 어디로 가는가 => 리듀서에서 캐치

액션 => type, payload가 담긴 객체

디스패치가 동작함으로써 액션 함수 안에서 데이터 요청 및 응답을 하고 액션을 보내면 리듀서에서 잡음

2) redux store 데이터를 전혀 사용하지 않음에도 불구하고 axios 통신을 위해서는 useDispatch() 함수의 사용이 반드시 필요한가 => 놉

미들웨어는 redux를 사용한다는 전제하에 보다 편리하기 위해 사용하는 것

3) 액션을 통해 axios에서 받은 데이터는 무조건 저장소를 거쳐야만이 컴포넌트에서 사용할 수 있는 건가 => 놉

4) 페이지에 따라 다른 폰트를 적용할 경우에도 폰트 폴더는 public에 있어야 하는 것인가 => Yes

5) 액션 함수의 매개 변수인 getState() 함수의 역할은 무엇이고 실행하면 어떻게 되는가 => 저장소 그 자체의 값을 반환해줌

또한 저장소는 콜 스택에 쌓여서 동기적 처리가 되기 때문에
액션을 던져주는 함수 바로 아래서 getState() 함수를 실행하면 변경된 저장소의 값을 바로 확인할 수 있음

6) 업로드 이미지를 DB에 저장하는 과정

input 태그의 file을 담은 formData와 다른 데이터들을 axios로 전송해서 multer 모듈을 미들웨어로 사용하면
해당 파일을 백엔드에서 받아서 저장하고 그 경로를 DB에 저장하는 것 

-- 11:04
상품 등록 중에 16th 문제 발생
string violation: img cannot be an array or an object

-- question
업로드를 위해 선택한 파일의 미리보기 기능에도 multer를 사용하는 게 좋나 => 놉 

그런데 formData를 사용해야 하는 이유... => 파일을 담으려면 필요...

날짜 및 시간을 DB에 어떤 형태로 저장해야 하나 => DATE 객체로 저장하고 DATE 함수를 사용해서 꺼내오면 됨!

-- 12:38
이미지 파일과 DATE 객체를 DB에 저장하고 꺼내오는 것부터 해보자.
multer 사용법...

그리고 상품 등록 시 미들웨어는 사용하지 않는 방향으로 코드 수정하자.

formData를 사용하지 않으면 multer에서 req.file로 캐치하지 못하나 본데...

-- 15:00
17th 문제 현상 발견

상품 등록 시 axios 통신 후 input의 값은 남아있으나 업로드한 이미지의 미리보기 태그가 사라짐
current 값도 1번은 남아있는데 등록하기 버튼을 2번 클릭하면 값이 초기화됨

그리고 갑자기숫자 타입의 input 태그에 문자 입력이 가능해짐

일단 multer를 사용해서 이미지 저장부터 하자...

multer로 업로드 이미지 파일 저장 시 한글 파일명의 인코딩에 대한 18th 문제 발생

-- 18:13
다른 방식으로 16th 문제 해결
아마도 객체를 DB에 저장하려고 하다 보니 그런 듯...

-- 17th 문제 해결 못 함
근데 교수님이 오시고 갑자기 잘 됨...
하 진짜... 이런 호랑말꾸 같은!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

아무래도 리렌더링이 아닌 어떠한 알 수 없는 원인으로 인해 새로고침이 이뤄졌던 듯?

그리고 몇 시간 내내 안 되던 file 객체의 name 키 값이 갑자기 잘 가져와짐

이러한 모든 현상이 교수님이 오시고 한참은 동일하게 안 되다가
어느 순간 갑자기 모든 게 해결되었음...
왜일까...
왜...

이런 숨바꼭질 같은...
이런 multer...

-- question
DB에 저장한 업로드 이미지 파일을 가져와서 이미지 태그로 보여주는 방법 => 배포 후 가능

DB에 저장할 이미지 경로 => 서버 실행 하는 작업 경로의 뒤에부터의 주소를 저장

-- 18th 문제 해결
file.originalname => Buffer.from(file.originalname, "latin1").toString("utf8");

-- 19:04
DB에 저장할 이미지 경로 수정하기

-- 21:38
DB에 저장할 이미지 경로 수정 완료

formData() 객체를 사용하지 않으면 req.file 값이 undefined이며 파일이 저장되지 않음
따라서 파일 저장 시에는 formData() 객체가 반드시 필요!

-- question
그런데 상품 등록 시 상품 이름이 기등록되어 있는 지 확인하고 나서 업로드 이미지 파일을 저장해야 하는데
multer 미들웨어를 어떻게 컨트롤해야 하지 => 익일 완료

-- 20:07
상품 상세 페이지를 이제 시작해보자.

그 전에 상품 등록 시에는 redux가 사용되지 않으니
액션 함수도 사용하지 않는 방향으로 코드를 수정해보자.

-- 20:35
상품 등록을 위해 axios 통신하는 함수로 코드 수정 완료

이제 DB에 저장된 상품 정보를 리스트로 가져와보자.

-- 20:57
프로젝트 볼륨을 최대한 작게 줄이자.
애초에 현재 판매 중인 상품의 수가 많지 않음을 전제로 해서
상품 리스트 페이지에 하나의 상품씩만 슬라이드로 보여주게 만들자.
이전 다음 버튼만 만들 것이야...

아니면 상품 리스트 페이지 없이 상품 상세 페이지만 만들어 놓고
이전 다음 버튼으로 페이지가 바뀔 수 있게 할까...

-- 21:22
상품 상세 페이지 구성 중 19th 문제 발생
React Hook "useState" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.

-- 해결
문법 => useState 및 useSelector 선언은 컴포넌트 함수 밖이 아닌 안에서

-- [ 22.10.14 ]

-- 09:17
어젯밤에 DB가 아닌 백엔드에서라도 이미지 파일을 가져와보려고 했으나 20th 문제 발생
<img src={require("../../../back/tmp/uploads/김세정 배우님_1.jpg")} alt="이미지" />

Uncaught Error: Cannot find module '../../../back/tmp/uploads/김세정 배우님_1.jpg'
Module not found: Error: You attempted to import ../../../back/tmp/uploads/김세정 배우님_1.jpg which falls outside of the project src/ directory. Relative imports outside of src/ are not supported.
You can either move it inside src/, or add a symlink to it from project's node_modules/.

-- 해결 못 함
아무래도 백엔드에 파일 접근은 어려운가 봄...

심지어 이렇게 기재하면 터미널에 어마무시한 양의 에러가 발생함
<img src={require("../../../back" + product.img_path)} alt="이미지" />

어쩔 수 없이 임시 이미지 파일이라도 올려 놓자...

-- 10:05
깃허브에 올린 파일 커밋 기록에서조차 삭제하는 방법

git filter-branch -f --index-filter "git rm --cached --ignore-unmatch 경로를 포함한 파일명" --prune-empty -- --all
git push --force --all

-- 11:31
작업 일지 작성 완료
작업 시작

오늘은 상세 페이지 구성만 해도 감지덕지야...

-- 12:12
DB에 저장된 상품 정보를 가져와서 보여주려고 하는데 21th 문제 발생
또 또 객체의 키 값에 접근이 안 됨...

-- 해결
파일 정리하면서 reducer 코드가 누락됨...

상품 등록 시 상품 이름의 중복 여부를 먼저 확인하는 미들웨어를 추가하는 과정에서 22th 문제 발생
계속해서 req.body 값이 빈 객체...

-- 해결
아무래도 formData() 객체를 사용할 경우
무조건 multer 모듈을 사용하지 않으면
req.body 값을 잡지 못하는 듯...

multer 공식 문서 깃허브에서
filefilter() 함수와 에러 핸들링 부분을 토대로 해서 멋드러지게 해결함!!!!

쿼리문에서 23th 문제 발생
Support for `{where: 'raw query'}` has been removed.

-- 해결
문법 => { where: name } => { where: { name } }

-- 15:35
그런데... 잠시 임시로 작성했다가 삭제한 setInterval() 함수가 왜 계속해서 작동하는 거죠...
아무리 서버를 껏다 다시 켜도 멈추지 않는 24th 문제 발생

-- 해결
dispatch() 함수와 useSelector() 함수가 계속해서 실행되기 때문...
useEffect() 함수 안에 가둬서 처음 한 번만 실행되게 하면 ok!

-- 15:57
redux에 상품 정보를 언제 어떻게 담을 것인가...

아무래도 쇼핑몰의 규모가 작고 상품의 수가 적으니
페이지 접속 시에

DB에 등록된 모든 상품의 정보를 가져와서
redux에 저장해놓고

상품을 추가하거나 삭제할 때마다
DB와 redux 값을 수정하는 게 좋겠군~

프론트의 redux 기준의 작업 순서
1. 리듀서 파일에 어떤 액션들을 던질 것인지를 먼저 기재해놓고 (스토어의 메뉴판 작성 단계)
2. 미들웨어 폴더의 액션 파일에 각 액션명에 대한 액션 함수를 작성하고 (각 메뉴의 레시피 작성 단계)
3. 백엔드 파일에서 각 axios의 요청 주소에 해당하는 라우터를 작성하고 (레시피에 따른 재료 손질 단계)
4. 이제 각 컴포넌트 파일에서 필요한 미들웨어 함수를 가져오면 끝! (메뉴 주문 시 서비스 제공 단계)

로딩 페이지 작업 중 25th 문제 발생
Objects are not valid as a React child (found: object with keys {page}). If you meant to render a collection of children, use an array instead.

-- 해결 => 문법 =>
function LoadingRedirect({ page }) {
    //
    return isComplete ? { page } : <Loading />;
  }

=>
function LoadingRedirect({ page }) {
    //
    return isComplete ? page : <Loading />;
  }

-- 18:12
처음 접속 시
일단 로딩 페이지를 보여주고
DB에서 모든 상품 정보를 가져와서 redux에 다 저장하고 나면
제대로 된 페이지를 보여준다!

-- question
1) useEffect는 렌더링 다음에 실행되는 것...!!!!!!

2) dispatch() 함수는 반환 값이 없기 때문에 then() 함수를 사용할 수 없다... 말이 안 되는 거라고...

3) 백엔드에서 미들웨어 함수의 역할은
next() 함수로 다음 단계를 연결해주거나 res.send로 응답을 종료하거나

-- 18:53
이제 해야될 건

redux에서 상품 정보를 하나씩 가져와서
각각의 상세 페이지 뼈대 구현

-- 19:21
DB에서 가져온 상품 정보의 첫 번째 id 번호를 redux에서 가져오려고 하는 과정에서 26th 문제 발생
Uncaught TypeError: Cannot read properties of undefined (reading 'length')

-- 해결
리듀서 파일에서 전달하지도 않은 payload 값으로 데이터를 변경하니 undefined 값이 되어버린 듯...

-- [ 22.10.15 ]

-- 15:40
작업 일지 작성 완료
작업 시작

자 redux의 상품 인덱스가 안 바뀌는지부터 확인해 보자...

-- 15:49
상품 인덱스에 null 값을 초기 값으로 주고
첫 접속 시에 DB에서 가져온 상품 정보를 redux에 저장할 때
첫 번째 로우의 id 값을 상품 인덱스에 저장했는데
NaN 값이 나오는 27th 문제 발생

-- 해결
redux 안에 state 객체 안에 products 배열과 productsIdx 키 값이 동시에 공존한다는 걸
상품 인덱스가 상품 배열 안에 들어있는 걸로 착각하고 코드를 작성해버렸잖아...
state.products.productsIdx => state.productsIdx

상품 인덱스는
각각의 상품 정보의 id 값을 이용하는 것이 아니라
상품 정보를 담은 배열의 인덱스를 사용해야 함

이 부분부터 바로 잡자구...

왜인지는 모르나 증감 연산자의 사용이 전혀 되지 않는다...
state.productsIdx++ => state.productsIdx + 1

-- 16:13
이전과 다음 버튼으로 상품 인덱스 관리하기 성공!

DB에 날짜 저장하고 가져와서 사용하는 방법
Date().toString() => new Date(string).toString()

이제 공동 구매 이벤트가 현재 진행 중인지, 시작 전인지, 종료되었는지를 계산해야 되는데...

근데 생각해보니까
첫 접속 시에만 DB에서 상품 정보를 가져와야 하는데

지금 내가 한 거는
상품 페이지를 접속할 때마다 상품 정보를 가져오는 거 아닌가... => 맞음, 다음 주 월요일날 해결함

상품 등록 시 시간 부분을 건드리지 않으면 초 부분이 현재의 초로 등록이 되어버리는 28th 문제 발생

노트북에서 git pull 하니 conflict 발생하는 29th 문제 발생

-- 해결
git merge --abort
새로운 폴더에 git 연결함

-- 21:35
28th 문제 해결
date 객체를 사용한 함수를 작성함

상품 등록 시
공동 구매의 시작 시각의 선택에 따라
종료 시각도 무조건 동일하게 변경되는 30th 문제 발생

원래 목표는 종료 시간보다
이후의 시작 시간을 선택할 경우에 대한 예외 처리를 하려고 했던 거였는데...

거기다 교수님의 요구사항을 다시 살펴 보니
상품 등록 시에
공동 구매 가격을 직접 입력하는 게 아니라
할인율을 입력해서 가격을 등록할 수 있게 변경을 해야되겠다는 생각이...

-- [ 22.10.16 ]

-- 23:08
30th 문제 해결, 예외 처리 완료

-- 23:29
공동 구매 할인율에 대한 태그를 추가함에 있어서 31th 문제 발생
Warning: Expected `onChange` listener to be a function, instead got a value of `string` type.

-- 해결
잠시 설정해두었던 부분을 삭제함 onChange={""}

-- [ 22.10.17 ]

-- 07:32
DB에 저장된 데이터가 하나도 없을 경우 계속 로딩 페이지에 남아 있는 32th 문제 발생

-- 해결
기존에는 redux에 담긴 상품 배열의 길이가 1 이상인 지를 통해서
state 값을 변경하고 그로써 로딩 페이지를 변화시켰는데

이제는 state 값을 redux에 저장하고
상품 정보를 담을 때 state 값도 같이 변경함으로써
로딩페이지를 변화시킴

또한 기존에는 이 페이지에 접속할 때마다 DB에서 상품 정보를 가져왔다면
이제는 redux의 state 값을 통해 맨 처음 한 번만 가져오도록 코드를 수정함

-- 08:12
즉시 구매가 및 공동 구매가의 값에 따른 자동 공동 구매 할인율의 입력에 대한 함수 작성 중...

즉시 구매가, 공동 구매가, 공동 구매 할인율의 입력에 따른
각각의 예외 처리 코드 작성 중...

-- 09:14
공동 구매의 날짜 및 시각 컴포넌트에서
state 값을 사용하는 것이 제대로 반영되는 지 확인 중...

실시간으로 선택한 값을 사용하는 데에는 state 값을 사용할 경우 한 박자씩 늦지만
이미 선택되어 있는 값을 비교할 때에는 state 값을 사용해도 됨을 확인함

-- 10:18
밀린 작업 일지 작성 완료
작업 시작

아니 근데 숫자 타입 input 태그에
어떤 때는 문자 입력이 안 되고 어떤 때는 되고 이러니
원인이 뭔 지 도통 알 수가 있어야지...?
예의주시 필요...

onChange() 때문인가...
아닌 듯...

도대체 원인이 뭐야!!!!!!!!

-- 11:13
즉시 구매가, 공동 구매가에 대해 여러 가지 예외 처리를 하다 보니
직접 입력이 막히는 33th 문제 발생

-- 해결
react에서 포커스 아웃은 onBlur
onChange() 함수 대신에 onBlur() 함수와 onClick() 함수 사용

-- 14:40
이렇게 하면
키보드로 입력할 경우에는 실시간으로 변동되지 않지만
포커스 아웃되거나 증감 버튼을 비롯해서 태그를 클릭할 경우에는
공동 구매가 및 공동 구매 할인율의 값이 자동 변동됨

input 태그에 문자 입력이 되는 이상 현상에 대해서
알 수 없는 어떠한 원인으로 인해 발생하고 나면
f5만으로는 해결되지 않는 듯 하다.

그래도 브라우저 상에서 마우스로 새로고침 하면
정상 작동 되는 듯 하다.

-- 15:06
상품 상세 페이지에
공동 구매의 날짜 및 시간을 어떻게 표시할 것인가...

과거
종료 시각 표시

현재
종료까지 남은 시간 표시

미래
시작 시각 표시

-- 16:19
DB의 상품 정보 데이터의 유무에 따라
만약 데이터가 없을 경우에
메세지 태그 하나만 생성하려고 하는 과정에서 34th 문제 발생
React Hook "useState" is called conditionally. React Hooks must be called in the exact same order in every component render.

-- 해결
useState() 함수 실행은 if 조건문 보다 상단에서 해야 하는 듯...

-- 17:05
이제 상품 정보 수정 및 삭제를 해볼까...

-- [ 22.10.18 ]

-- 08:29
상품 등록 시 즉시 구매가 0원 선택 후 공동 구매가 1000원 선택하면
alert 무한 반복의 35th 문제 발생

-- 10:17
작업 일지 작성 완료
작업 시작

어떻게 하는 것이 컴포넌트화를 잘 하는 것인지 모르겠다...
일단은 돌아가게라도 만들자.

-- 11:34
상품 등록 및 수정 컴포넌트의 state 값의 초기화는 필요 없는 듯

공동 구매 시작 시각 및 종료 시각의 state 값 사용에 대하여
부모 컴포넌트의 state 값을 사용하는 이유는
부모 컴포넌트의 등록 및 수정하기 버튼 클릭 시 DB에 저장하기 위해

-- question
1) useSelector() 함수의 반환 값이 처음엔 undefined인 이유...

useSelector() 함수가 여러 번 실행되는 이유...

=> 함수형 컴포넌트 내에 스코프 실행 => 랜더링 => useSelector(), useEffect() => 함수형 컴포넌트 내에 스코프 재실행 (리랜더링)

그래서 && 필요...

2) 상품 등록 시 공동 구매 할인율의 자동 입력 과정에서의 무한 alert 해결 방법

=> state 값을 이용해서 if 조건으로 alert 생성

3) 상품 정보 수정 페이지에서 파일 선택법...

우선 input 태그에 파일을 넣으려면
이미지를 파일 형태로 바꿔야 하는데 굉장히 복잡하며...

무엇보다 로컬에 파일이 저장되어 있어야 하기 때문에
서버에서 로컬로 파일을 다운로드 한 다음에
input 태그에 담아야 함

그러므로 기존의 이미지는 보여주는 용도로만 사용하고
input 태그는 변경할 경우에 선택할 수 있도록 하는 것이 올바른 방향

4) 로딩 페이지

action 함수 내에서
로딩에 대한 redux의 state 값을 변경하는 액션을 담은 dispatch를 추가적으로 실행한다.

로딩창
app.js 파일의 헤더 부분에서 state 값에 따라 로딩 컴포넌트의 유무를 다루거나

로딩 페이지
원래 내가 했던 대로
state 값에 따라 로딩 컴포넌트와 원래 페이지 중 하나만 다루거나

-- 16:45
35th 문제 해결

-- 17:04
useSelector() 함수 사용의 최적화 방법

1) 독립 선언

2) equalityFn 파라미터 사용

equalityFn 는 이전 값(prev)과 다음 값(next)을 비교하여
true가 나오면 다시 렌더링을 하지 않고
false가 나오면 렌더링을 진행 합니다.

const { count, prevCount } = useSelector((state: RootState) => ({
    count : state.countReducer.count,
    prevCount: state.countReducer.prevCount,
  }),(prev, next) => {
    return prev.count === next.count && prev.prevCount === next.prevCount;
  });

3) shallowEqual 함수 사용

shallowEqual 는 selector로 선언한 값의 최상위 값들의 비교 여부를 대신 작업해 줍니다.

const { count, prevCount } = useSelector((state: RootState) => ({
    count : state.countReducer.count,
    prevCount: state.countReducer.prevCount,
  }), shallowEqual);


-- question
1) 이미지 태그에 프론트 쪽 src 폴더의 이미지 파일을 사용하려 할 때
require() 함수 안에 문자열 이외에는 사용이 불가한가 => Yes

=> 웹팩 부분에서 터지는 거라고 함

배포 후 서버에서 이미지 경로를 가져올 때는
require 없이도 도메인 주소만 앞에 붙이면 된다고 함

2) useState() 함수의 초기 값에 삼항 연산자를 사용하는 게
과도한 리렌더링의 방지를 위해서 맞는 걸까
아니면 별 의미가 없는 걸까...

=> 과도한 리렌더링은 주의해야겠지만
극도로 경계할 필요는 없다.

또한 ustState() 함수의 초기 값으로 삼항 연산자를 쓰는 경우는 별로 없다고 한다.

-- 19:00
상품 등록 및 수정 페이지의 이미지 태그에 대하여
파일 변경 유무에 대한 설정 완료

다음 작업은 변경한 상품 정보 DB에 저장하기

근데 해당하는 상품의 로우를 삭제한 다음 새로 추가하는 게 낫나
아니면 변경한 컬럼들을 일일이 찾아서 부분 부분적으로 변경하는 게 낫나...

로우 자체를 덮어쓰기는 안 되겠지...

-- [ 22.10.19 ]

-- 09:36
작업 일지 작성 완료
작업 시작

오늘의 목표
로그인 토큰 발급...

-- question

오늘의 토큰 작업 플로우

1. 회원 가입 시 (프론트) 비밀 번호 암호화하여 DB에 저장 (백)
2. 로그인 시 (프론트) DB에 저장된 비밀 번호 복호화 (백)
3. 비밀 번호 일치 시 액세스 및 리프레쉬 토큰 발급 (백)
4. DB에 리프레쉬 토큰 저장 (백)
5. 액세스 및 리프레쉬 토큰 세션 스토리지에 저장 (프론트)

6. 액세스 및 리프레쉬 토큰과 함께 요청 (프론트)
7. 액세스 토큰 검증 (백)
8. 정상이면 반환 (백)
9. 정상이 아니면 먼저 DB에 저장된 리프레쉬와 동일한 지 확인 (백)
10. 불일치하면 로그아웃 (프론트)
11. 일치하면 리프레쉬 검증 (백)
12. 정상이면 액세스 토큰 재발급 (백)
13. 정상이 아니면 로그아웃 (프론트)

로그인 여부를 확인하는 요청 시에
액세스 토큰이 정상이면 프론트의 로그인을 유지시킨다는 것
즉 로그아웃 절차가 필요 없다는 것

토큰이 정상이 아닐 경우에 로그아웃 및 재로그인시킨다는 것은
프론트의 저장소의 로그인 정보 및 로그인 유지 정보를 초기화시킨다는 것

토큰에는 비밀 번호를 제외한 모든 유저 정보를 담아도 된다고 함

-- 10:37
일단 유저 모델 생성 부터!

-- 10:58
모델 생성 완료
이제 axios로 백엔드와 통신하려고 하는데

그 전에 useRef를 이렇게 쓰는 이유가 뭐지...
ref={(el) => (userData.current.userId = el)}

<input ref={inputRef} />

React의 ref prop은 HTML 엘리먼트의 레퍼런스를 변수에 저장하기 위해서 사용합니다.

예를 들어, 다음과 같이 <input> 엘리먼트에 ref prop으로 inputRef라는 변수를 넘기게 되면,
우리는 이 inputRef 객체의 current 속성을 통해서 <input> 엘리먼트에 접근할 수 있고,
DOM API를 이용하여 제어할 수 있습니다.

그렇다면 ref props에 ref 객체가 아닌 일반 변수를 넣어도 태그를 제어할 수 있나...
안 되는 듯...

-- question

1) 콜백 함수 내에서 await 사용이 불가한 지...

=> 이미 promise가 종료된 콜백 함수 내에서
그 값을 단순히 변수에 넣는 것은 사용의 의미가 없음

2) ref props 사용에 일반 변수는 사용이 불가한 지...

=> useRef() 함수 전용임
또한 useRef() 함수에 boolean 값을 이용해서
componentDidMount() + componentDidUpdate() 상태에서 componentDidUpdate() 상태만 추출할 수 있다고 함

componentDidMount() => 최초의 랜더링 직후

-- 12:20
1번 플로우 완료

-- 14:51
점심 서브웨이
잠시 해커톤 멘토링 준비 - 데이터 관리 계획

-- 15:08
2번 플로우 완료

-- 15:32
3, 4번 플로우 완료

잠시 해커톤 회의

-- question
1) 토큰을 세션 스토리지에 저장한다는 건...
프론트의 세션 스토리지에 겟아이템 함수로 저장하는 것

이렇게 하면 req.session에 저장되기 때문에
추후 요청 시 백엔드 쪽으로 토큰을 전송하지 않아도 된다.

2) 액세스 토큰을 재발급할 경우에...
리프레쉬 토큰을 재발급하지 않아도 되고
변경된 액세스 토큰만 새로 저장해주면 된다.

3) 리프레쉬 토큰을 재발급하는 경우는...

오직 로그인 했을 때!
따라서 리프레쉬 토큰이 변경되었다는 것은 재로그인 했다는 것.

재로그인이 필요할 때는
더 이상 DB에 저장되어 있는 리프레쉬 토큰이 사용되지 않기 때문에
삭제하지 않아도 괜찮고
재로그인 시에 덮어쓰기 해주면 된다.

또한 리프레쉬 토큰이 재발급으로 변경되었을 때만 DB에 저장해주면 된다.

4) 토큰에 비밀 번호를 제외한 유저 정보들을 저장한다면
redux 저장소에는 유저 정보를 저장하지 않아도 되나...

그렇게 해도 되지만 그러면 매번 백엔드 쪽에서 검증을 해줘야 하기 때문에 자원이 많이 소모된다고 함
편하게 작업하려면 저장소에도 유저 정보를 저장해도 괜찮다고 함

5) 토큰을 어디에 저장해야 할까...

쿠키보다는 세션에 저장하는 것이 보안에 더 좋은 것은 맞지만
결국엔 어떻게 하든 다 뚫린다고 한다...

6) 상품 정보 수정 시 DB 변경 방법
변경한 컬럼의 데이터만 수정해줘야 한당...

7) 아이디 중복 확인 같은 간단한 DB 조회 작업 시에
조건을 최소화해서 해당 로우를 전부 가져오는 것이 나은 것인가
아니면 조건을 달더라도 해당 로우에서 최소한의 데이터만 가져오는 것이 나은가

후자가 나은 듯 하다고 함...

-- [ 22.10.20 ]

-- 08:01
작업 일지 작성 완료
작업 시작

-- 08:18
5번 플로우 완료

-- 08:46
헤더 컴포넌트 생성 완료

-- 09:40
상품 등록 페이지에서 공동 구매 할인율 입력 시
공동 구매가만 자동으로 계산함으로써
즉시 구매가와 공동 구매가, 공동 구매 할인율이 모두 유기적으로 연결되어 있지 않는 36th 문제 발생

-- 해결
공동 구매가를 자동으로 계산하고 난 뒤에
그에 맞는 공동 구매 할인율을 다시 계산하도록 코드 수정 완료

-- 10:48
상품 등록 시 실시간으로 저장소에 추가될 수 있게 코드 수정

-- 11:24
상품별 상세 페이지의 공동 구매 날짜 및 시간에 대해서
기존에는 무조건 1초 뒤에 1초마다 렌더링 되게 설정했었는데

이제는 바로 표시되게 하고
진행 중일 경우에만 0.5초마다 반복해서 렌더링 되게 코드 수정 완료

-- 11:49
상품 구매하기 버튼 클릭 시
비로그인 상태일 경우
로그인 페이지로 이동하는 기능 구현 완료

이제 토큰 검증의 단계를 구현해보려는데

그 전에
로그인 성공 시 메인 페이지로 어떻게 이동을 시켜야 할 지...

-- 12:07
로그아웃 시
세션 스토리지에 저장해 둔 토큰 부분만
삭제하게끔 코드 수정 완료

-- 12:22
세션 스토리지에 저장된 토큰이 백엔드에서 조회가 안 되는 걸...

토근 검증의 시기...

-- question
1) 프론트 쪽 세션스토리지에 토큰을 저장하고 나서
백엔드 쪽에서 req.session으로 조회가 안 되는 이유...

ejs나 넌적스를 사용해서 클라이언트에서 직접 브라우저를 띄우는 게 아니기 때문에

서버와 클라이언트가 분리되어 있는 상태에서
클라이언트 쪽 브라우저의 세션에 토큰이 저장되어 있는 거고
서버 쪽 포트는 열려 있는 브라우저가 아니기 때문에
데이터를 직접적으로 전달해줘야 한다...

2) 토큰 검증의 시기...

로그인이 필요한 모든 페이지에서...

3) 액션 함수 내에서 axios의 결과 값에 따라 페이지를 이동시키고 싶다면...

액션 함수의 매개 변수로 원하는 함수를 전달하면
액션 함수 내에서도 실행 가능!

-- 14:14
백엔드로 토큰 보내기 전에 axios 통신에 대한 전반적인 코드 수정 중...

근데 액션 함수 내에서 동기적 처리를 할 수는 없는 걸까...

-- 15:00
토큰 검증의 결과는

iss 토큰 발급자
exp 토큰 만료 시간
iat 토큰 발급 시간

세션 스토리지에 저장되어 있다면 로그인 유지...

--question
jwt.verify() 함수는 이미 프로미스 객체로서
fuction 함수 안에서 이 함수를 반환하면
단순히 이 함수를 내보내는 것이 되고

그런데 왜 프로미스 객체에 await를 안해도 기다려지는 거지...

async fuction 함수 안에서 이 함수를 반환하면
프로미스 객체의 값이 나올 때까지 기다리는 함수를 반환한다고 한다...

-- 17:36
즉시 구매하기 버튼 클릭 시
로그인 여부 확인하고
미들웨어로 토큰 검증해서

바로 구매 성공하거나
액세스 토큰을 재발급하고 구매 성공하거나
세션 스토리지의 토큰을 삭제하고 로그아웃 페이지로 이동시키기

구현 완료

남은 작업은...

재발급한 액세스 토큰을 세션 스토리지에 새로 저장하고

페이지를 새로고침 했을 때
세션 스토리지의 데이터에 따라 로그인 상태 유지시키기...

그리고 회원별 상품 거래에 대한 시퀄라이즈 모델 생성해서
거래에 대한 데이터 기록하기

-- [ 22.10.21 ]

-- 08:09
거래 기록에 대한 시퀄라이즈 모델 생성 중에 37th 문제 발생
Transaction.init is not a function

-- 해결
문법 => module.export => module.exports

-- 08:37
로딩 페이지가 2초간 더 유지 되게 코드 수정

다음 작업은 마이 페이지의 거래 내역...

-- 09:58
작업 일지 작성 완료
작업 시작

거래 내역에 대해서
즉시 구매와 공동 구매로 분리하여 모델 생성 완료

이제 각각의 구매 시에
해당 테이블에 데이터를 추가해보자

-- 10:12
액세스 토큰 재발급 시
세션 스토리지에 다시 저장 완료

뭐지...
왜 app 컴포넌트에서 300여 번의 랜더링이 일어나는 거지...

-- 10:47
즉시 구매 시 거래 내역 DB에 저장 완료

백엔드 쪽 컨트롤러 폴더의 사용을 잘 모르겠단 말이지...

-- 12:30
dotenv.config()의 반환 값이 없어도 env 파일에 접근이 가능한가...
오오오 config 폴더 안에 딱 한 번만 선언해도 접근이 가능하네...!

-- 12:35
백엔드의 app.js 파일을 담을 controller 폴더 생성 완료
백엔드의 라우터 폴더 생성 및 라우터 분리 완료

이 모든 건
즉시 구매와 공동 구매에 대해서
중복을 피하고자 하는 마음에서 시작되었다...

-- 13:07
즉시 구매와 공동 구매 시
상품 정보와 회원 정보 DB에 저장하기 완료

이제 마이 페이지에
거래 내역을 띄워보자...

-- 13:44
그 전에 findOrCreate() 함수를 사용해보자!

-- 14:00 완료
이제 진짜로 거래 내역을 띄워보자...

즉시 구매와 공동 구매의 거래 내역을
한 데 모아서 정렬된 형태로 보여주려고 하니
테이블을 합쳐야 하는 걸까 잠시 고민했지만

데이터를 받아오고 나서
후처리 하면 될 거 같아서 도전해보기로!

-- 14:43

-- question
1) 마이 페이지 접속 시 백엔드로 안 넘어가는 가는 이유

=> 요청을 안 해서...
포트가 따로 열려있어서 요청이 있어야 한다고 함

마이 페이지의 componentDidMount() 시점에 axios 통신으로 요청해보기

2) 백엔드 쪽에 사용하는 함수 모음집은 어느 폴더에...

=> 기능 단위의 함수들을 서비스 폴더에 담고
서비스에서 꺼내서 컨트롤러에서 사용한다.

컨트롤러 폴더에는
get, post 같은 api 작업들을 담는데

라우터로 나눌 수도 있다.

폴더 구조
controller => app.js, 라우터 폴더의 index.js
service
router

리액트는 뷰 중심적 어플리케이션으로
싱글 페이지의 렌더링이 이루어지며
mvc 패턴이 아닌 flux 패턴이다.

3) app.js 파일의 액션 때문에 과도한 렌더링이 발생하는 38th 문제

원인 =>

if (!isDoneLoading) {
    //
    dispatch(getAllProducts_action());
  }

_dispatch({ type: "GET_ALL_PRODUCTS", payload: products });
//
setTimeout(() => _dispatch({type: "LOADING_DONE"}), 2000);

DB에서 상품 정보를 다 가져오고 나면
products의 값이 바뀜으로서
app.js 파일이 리랜더링되는데

setTimeout() 함수로 인해 아직 로딩에 대한 state 값이 바뀌지 않은 상태라
2초 동안은 계속해서
상품 정보를 가져오는 액션을 던지게 되고
이로 인해 과도한 리랜더링이 발생하게 된 것이었다!!!!

근데 해결 방법은....

4) 페이지를 새로고침 했을 때 세션 스토리지의 데이터를 확인해서 로그인을 유지시키려면...

새로고침을 한다는 건 app.js 파일을 거친다는 것

app.js 파일에서 토큰을 검사하고 로그인 액션을 취한다.

토큰이 정상일 경우에만
저장소의 로그인 여부를 바꾸고
유저 정보를 저장소에 담는다.

아닐 경우에는
로그인이 풀린 상태로
세션만 비우면 되겠지...

토큰 검증 시에
토큰에 담긴 유저 정보를 사용하는 게 맞다.

따라서 리프레쉬 토큰의 검증 순서는

검증 먼저하고
DB와 동일한 지 확인한다.

5) async function 함수 안에서 왜 await를 안해도 프로미스 객체가 기다려지는 거지...

프로미스의 고급 버전이 async, await...

프로미스 객체를 바로 사용하는 게 아니라
함수 안에 담는 거라 async를 붙여줘야 된다고...

콜백 함수의 매개 변수가 없는 jwt.sign() 함수에서는
동기적으로 처리가 되기 때문에 프로미스 객체를 사용할 필요가 없다고...

-- 17:21
38th 문제 해결
useEffect() 함수를 사용해서
componentDidMount() 시점에 딱 한 번만 액션을 던지도록 코드를 수정함

-- 17:28
페이지 새로고침에 대해서...

-- 18:09
회원 전용 페이지에 대해서
토큰을 검증하는 미들웨어 함수를 거치게 할 경우

회원 전용 페이지에서 새로고침 했을 때

app.js 파일의 componentDidMount() 시점에서 토큰 검증 한 번,
회원 전용 페이지의 미들웨어 함수에서 또 한 번 토큰을 검증하게 된다.

새로고침 시 로그인을 유지시키는 기능으로서 토큰을 검증하고
데이터를 가져오는 작업으로서 또 한 번 토큰을 검증하는 거라면
말이 되지...

근데 과연 괜히 과도한 건 아닌 걸까...

ㅁㅅ님은 백엔드에서의 미들웨어 함수는 전혀 사용하지 않고
토큰 검증 전용의 라우터 요청을 분리하여
app.js 파일 내에서
페이지 이동 시마다
토큰 검증의 컴포넌트를 거치게끔 하셨다고 한다.

만약 모든 주소의 이동 시마다
토큰을 검증할 거라면
useEffect() 함수를 사용해서
[ location.path ] 값이 변동될 때마다
요청을 보내는 방법도 있다고 한다!

근데 혹시 페이지별이 아닌
항목별로 토큰을 검증해야 하는 경우가 있진 않을까...

일단은 하던 대로 직진하기로!

그런데 app.get()의 정확한 명칭이 무엇인가...

-- 18:32
토큰 검증만 하는 액션을 생성할 예정...

그리고 토큰 검증 시
토큰에 들어있는 유저 정보를 활용하는 방향으로
코드 수정 예정

-- 18:59
새로고침 시 로그인 유지 기능 구현 중에 39th 문제 발생
redux.js:275 Uncaught Error: Actions must be plain objects. Instead, the actual type was: 'undefined'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions.

-- 해결
문법 => dispatch() 함수 안에 액션 안 넣어줌

-- 19:18
새로고침 시 로그인 유지 기능 구현 완료
리프레쉬 토큰의 확인 과정의 순서 조정 및 토큰 안에 있는 유저 정보를 활용하는 코드로 수정 완료

이제 마이페이지에 거래 내역 불러오면 되나요.... 흐흐흫

-- 19:37
타의로 로그아웃 될 경우 로그인 페이지로 이동시키고
자의로 로그아웃 할 경우 메인 페이지로 이동시키기 구현 완료

-- 19:55
다음 작업은 DB에 저장되어 있는 거래 내역을 활용해서 로그인한 회원의 마이 페이지 구현

-- 22:16
마이 페이지에 대해서 프론트와 백엔드 연결 중에 40th 문제 발생
jwt must be provided

-- 해결
=> 토큰이 undefined 라서
axios method => get => post 변경

get 방식은 데이터를 보내지 못하나 봄...

-- [ 22.10.22 ]

-- 17:26
15시쯤부터 작업...
어제부터 전반적으로 코드 수정 및 최적화를 진행하다 보니
오류가 여기저기서 터져서 잠깐만 작업한다는 게
기록도 하지 못했다.

마이 페이지에서 프론트와 백엔드 연결 했고

마이 페이지에서 새로고침 했을 때
토큰 검증 절차를 두 번 거치지 않도록
저장소의 state 값을 하나 더 사용해서 코드를 수정했고

문제는 이제 거래내역을 어떻게 표시할 것인가에 대해 결정해야 하는데...

그리고 가끔 alert이 여러 번 발생할 때가 있는데...

로그인할 때...

정확히 언제 발생하는 건지에 대해서 좀 더 지켜보도록 하자...

-- [ 22.10.23 ]

-- 21:56
마이 페이지의 거래 내역 구현

-- 23:47
거래 내역 뼈대 완성

거래 내역에서 상품명 클릭하면
해당 상품 페이지로 이동할 수 있게 할까...

-- [ 22.10.24 ]

-- 07:21
쪽지 모델을 만들 것이야...

그 전에 환불 기능부터 만들고...!

-- 10:03
밀린 작업 일지 작성 완료
작업 시작

환불 기능 만드는 데
거래 내역 화면에서
해당 하는 거래를 찾는 방법은
구매 방식, 상품 이름, 구매 시각으로 결정

-- 10:15
환불 후
로그인 페이지로 이동하는 41th 문제 발생

환불하고 나서 마이 페이지를 다시 접속해서 그런가
추가로 토큰 검증을 하는 거 같진 않은데...

-- 해결

문법 => 
const toLoginPageFn = nav("/login");

=>

const toLoginPageFn = () => nav("/login");

-- 11:29
환불 후 재렌더링 시
저장소의 거래 내역이 null 값이 되어버리는 42th 문제 발생

도통 모르겠음...

거래 내역 화면에서
상품명 클릭 시

해당하는 상품 상세 페이지로 이동하는 기능 구현 중

생각해보니 바로 구매 상품이든 공동 구매 상품이든
기본 키인 id 값은 동일하다는 것을
이제야 눈치 챔...

그렇다는 것은
굳이 즉시 구매와 공동 구매로 경우의 수를 나눠서
까다롭게 예외처리 하지 않아도 됬었다는 것...

상품 구매부터 다시 코드 점검하자...

-- 11:56
상품 구매 시
저장소에 해당 거래 내역이 추가되도록 코드 수정 완료

-- 12:20
42th 문제 해결

바보...
리듀서에서 null 값의 변수를 넣고 있었어...

-- 12:24
환불 시 재랜더링이 안 되는 43th 문제 발생 

환불 클릭 시 배열인 거래 내역의 값을 못 가져온 44th 문제 발생

-- 해결
상품 구매 시 거래 내역에 추가할 때
리듀서에서 배열 형태의 스프레드 연산자를 사용해서
저장소 값을 변경했어야 하는데

객체로 저장해버림...

-- 12:54
마이 페이지에서 마이 페이지를 한 번 더 클릭하면
구매 시각이 사라지는 마법 같은 45th 문제 발생

-- 13:10
43th 문제 해결

리듀서에서 저장소의 값을 변경할 때
기존 배열에 값만 변경하는 forEach() 함수를 사용하는 것이 아니라
새로운 배열을 생성하는 map() 함수를 사용하니까
리랜더링 잘 됨

-- 13:54
45th 문제 해결

if 조건 문법 =>
el.Product.type = payload.type => el.Product.type === payload.type

하... 이건 오래 걸렸다 ㅠㅠㅠ

-- 13:59
이제 거래 내역 화면에서
상품명 클릭 시
해당 상품 페이지로 이동하는 기능 구현할 거임...

-- 14:07
상기 기능 구현 완료

마이 페이지의 componentDidMount() 시점에
DB의 거래 내역을 가져오는 액션을 던졌더니

마이 페이지에 접속할 때마다
매번 가져오는 현상이 발생하여

상품 데이터처럼
로그인 했을 때
거래 내역 정보를
다 가져오도록 코드를 수정할 예정...

-- 16:04
환불 시 환불 시각이 업데이트 되도록
백엔드에서 환불 여부를 수정한 후
업데이트한 시각을 꺼내서
프론트로 보내줌으로써 해결

하루 종일 미친 듯이 집중해서 하긴 했는데
이거 고쳤다 저거 고쳤다 하느라고
뭐 한 지도 모르겠다...

이제 회원의 포인트 기능과 쪽지 기능을
만들어보자꾸나...

-- 16:31
포인트에 대한 컬럼 생성 완료
쪽지에 대한 시퀄라이즈 모델 생성 완료

-- 17:00
포인트 관련 해서 얼추 코드 수정 완료

그런데 확인해보려면 마이 페이지만의 메뉴를
생성해야 할 듯....

-- 17:11
포인트 기능 구현 완료!!!!

-- 17:30
마이 페이지 전용 헤더 컴포넌트 생성 완료

-- [ 22.10.25 ]

-- 09:33
작업 일지 작성 완료
작업 시작

-- 09:59
회원 모델에 닉네임 컬럼 추가 완료
회원 가입 시에 알림 쪽지 데이터 생성 완료

-- 11:14
저장소에 저장되어 있는 알림 쪽지 데이터를
일반 변수에 담아서 자식 컴포넌트에 보내주면 안 되나...

-- 11:24
새로고침했을 때 저장소의 값...

자 회원 정보에 대해서
어디에 무엇을 저장할 건지를
다시 생각해보자.

우선 토큰에는 회원의 아이디만 저장할 거고

저장소에는
로그인 여부,
DB에 저장된 회원의 인덱스 값,
닉네임, 현재 포인트,
알림 쪽지 내역,
거래 내역을 저장할 거야.

그렇다면 과연
토큰 검증하는 미들 웨어 안에서
회원의 인덱스 값을 가져올 필요가 있을까...

먼저 로그인 되어 있을 경우에는
저장소에 저장되어 있는
회원의 인덱스 값을
백엔드로 보내주면 돼.

그러니까 미들웨어 안에서
굳이 한 번 더 회원의 인덱스 값을 찾을 필요가 없다는 거야...

그리고 로그인이 되어 있지 않을 경우에는...

저장소에서 로그인 여부를 확인해서
로그인이 안 되어 있으면
프론트에서 로그인을 요구하면 돼.

마지막으로 새로고침 했을 때는...

저장소는 당연히 텅 빈 값일 테고
세션에 토큰이 저장되어 있는 지를 확인해서
백엔드에 토큰 검증을 요청하고

성공한다면
마치 로그인한 것처럼
그리고 로그인 할 때처럼
프론트에 회원의 정보를 넘겨줘서
저장소에 저장해야 돼.

-- 11:48
페이지 첫 접속 시
세션에 토큰이 저장되어 있는 지 확인 후
토큰 검증 및 회원의 정보,
그리고 상품 정보까지
모두 가져오면
그 때 비로소 로딩 페이지에서 벗어나게 해야 해...

-- 12:02
그러려면 저장소의 state 값을 쪼개자.

-- 12:15
리듀어에서 새로운 저장소 객체로 변경하지 않고
안의 값만 변경한 다음
app.js 파일에서
useEffect() 함수를 사용한다면
과연 로딩 페이지에서 벗어날 수 있을까...

-- 12:28
역시 안 됨
다른 액션 함수로
저장소 객체를 변경한다면
리랜더링 될 수 있겠지만

모든 액션 함수에서
저장소 객체를 변경하지 않는다면
아예 리랜더링이 이루어지지 않음

새로고침 시
회원 정보를 체크하고
상품 정보가 모두 준비되었을 때
2초 후 로딩 페이지에서 벗어나도록 코드 수정 완료

이제
로그인에 성공했을 경우에
회원 정보를 가져오는 동안
로딩 페이지를 보여야 함!

이 모든 건
새로고침 시에
토큰 검증하는 미들 웨어 함수를 점검하는 것에서 시작되었다...

-- 12:59
상품 정보랑 회원 정보는
저장소 객체가 바뀌어야
랜더링 되면서

로딩 페이지에서 벗어나는 액션 함수를 던질 수가 있다...

그리고 로딩 페이지에서 벗어나는 것도
저장소 객체가 바뀌어야
리랜더링이 이루어질 것이다...

하지만
로그인 했을 때는
다시 로딩 페이지로 값만 바꿔주고

이후
로딩 페이지에서 벗어날 때만
저장소 객체를 바꿔서 리랜더링 해주면 되지 않니...

-- 13:16
첫 접속과 로그인 시에
로딩 페이지에 대해서 코드 수정 완료

-- 13:52
시퀄라이즈 update() 함수는 반환 값이 [1]

-- 14:27
로그인 시에 저장소에
DB에 저장된 회원의 인덱스 값,
닉네임, 현재 포인트,
알림 쪽지 내역,
거래 내역을
모두 저장하기 위해
include 옵션을 사용해서
한 번에 찾도록 코드 수정 완료

다만 토큰 검증 시에
리프레쉬 토큰의 동일 여부와

로그인 시에
비밀 번호 동일 여부에 대해서는

해당 목적이 분명하고
동일하지 않을 경우에는
백엔드에서 추가적인 데이터 작업이 필요하지 않으므로

DB 데이터 조회함에 있어서
분리함

이제 이걸 새로고침 시에 이뤄지는
토큰 검증 시에도 적용해볼까...

-- 14:57
백엔드에서 회원 정보인

DB에 저장된 회원의 인덱스 값,
닉네임, 현재 포인트,
알림 쪽지 내역,
거래 내역을 가져오는 과정을
함수로 만들어서

새로고침 시에도
저장소에 회원 정보를 저장할 수 있도록 코드 수정 완료

이제 확인할 건
포인트가 실시간으로 확인 되는 지,
그리고 환불 기능, 알림 쪽지 기능...

-- 15:17
로그인 및 회원 가입 화면에서
라벨 태그 생성하고

빈 값의 예외 처리 완료

-- 16:13
회원 정보 수정 페이지에서
아이디랑 비밀 번호도 변경할 수 있게
하위 컴포넌트까지 생성해서 작업하려고 했지만

시간이 얼마 안 남았으니
닉네임 변경만 가능하게 하자...

아직은 회원 정보 수정 페이지만 만들었고
수정 작업은 나중에 하는 걸로...

-- 16:39
환불 기능 코드 수정 완료

-- 16:59
닉네임 수정 기능 구현할 예정...

그런데 input 태그에서
useRef() 함수를 사용하는 것과
useState(), onChange() 함수를 사용하는 것에

차이가 무엇일까...

-- 17:20
닉네임 변경 기능 완료

남은 건 관리자 모드에 대한 거랑...

관리자 페이지랑...
상품별 공동 구매 수량...

그리고 회원 전용 페이지 막기...

-- question
1) 일반 변수와 useState() 함수를 사용하는 경우의 차이

=> 일반 변수는 그릴 때마다 값이 초기화 되기 때문에
초기화가 되어도 괜찮은 경우나 초기 값을 그대로 사용할 경우에는
일반 변수를 사용해도 되고

이전의 값이 남아있어야 할 경우에는
useState() 함수를 사용한다...

또한 useEffect() 함수 안에서
일반 변수만 사용할 경우에는

useEffect() 함수는 랜더링 이후에 이루어지기 때문에
변수의 값이 변경되기는 하지만
리랜더링이 되지 않기 때문에
적용이 되지 않는다...

2) input 태그에 있어서 useRef() 함수와 useState() 함수를 사용하는 경우의 차이

=> useState() 함수는 실시간으로 입력 값을 보여주고자 할 때 사용하는 것이고
실시간으로 사용하지 않는 값을 변수에 저장하고자 할 때는 useRef() 함수를 사용한다고 한다...

useSelector() 함수 사용에 있어서
저장소에 이미 값이 들어있다고 하더라도
useSelector() 함수의 초기 값은 저장소 자체의 초기값이고
그 이후에 실제 저장소의 값을 가져온다고 한다...

3) app.get() 함수의 명칭

=> express에서 http 요청 방식을 사용할 수 있도록 해주는 함수라고 한다...

4) 관리자 페이지에 필요한 것

=> 비매너 유저에 대한 유저 삭제 기능, 원한다면 정지 기능까지...
재가입을 막고 싶다면 deleted_at 컬럼을 사용해야 한다...

-- 18:48
마이 페이지 접속 시 토큰 검증을 안 해서 그런가
일정 시간 이후에 쪽지 내역이 안 나오는 거 같네...

-- 19:51
마이 페이지에서 닉네임 변경 기능 구현 완료

다음 작업은
관리자 아이디를 비롯해
상품에 대해 초기 데이터 만들어서 넣기...